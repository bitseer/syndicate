#!/usr/bin/env python 

"""
   Copyright 2013 The Trustees of Princeton University

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"""

import sys
import os
import syndicate.rg.common as rg_common
import syndicate.rg.main as rg_main
import signal
import resource
import daemon 
import grp
import lockfile
import errno 
import time

log = rg_common.get_logger()

#-------------------------------
def daemonize( config, syndicate, main_method ):
   signal_map = {
      signal.SIGTERM: 'terminate',
      signal.SIGHUP: None,
      signal.SIGUSR1: syndicate.sched_reload
   }
   
   daemon_gid = grp.getgrnam('daemon').gr_gid
   
   output_fd = None
   error_fd = None
   
   if config.get("logdir", None) != None:
      # create log files
      # TODO: access.log, error.log
      output_fd = open( os.path.join(config["logdir"], "RG.log"), "w+" )
      error_fd = output_fd 
      
      os.dup2( output_fd, sys.stdout )
      os.dup2( output_fd, sys.stderr )
      
   else:
      # write to stdout and stderr
      output_fd = sys.stdout 
      error_fd = sys.stderr
   
   context = daemon.DaemonContext( umask=0o002, prevent_core=True, signal_map=signal_map )
   
   # don't close these if they're open...
   files_preserve = []
   if output_fd:
      files_preserve.append(output_fd)
   if error_fd and error_fd != output_fd:
      files_preserve.append(error_fd)
   
   context.files_preserve = files_preserve
   
   # pid file?
   pidfile_path = config.get("pidfile", None) 
   if pidfile_path:
      context.pidfile = lockfile.FileLock(pidfile_path)
   
   # start up
   with context:
      main_method()
      

#-------------------------------
def spawn_rg( config, syndicate ):
   # fork, become a watchdog, and run the main server
   child_pid = os.fork()
   
   if child_pid == -1:
      # failure
      raise Exception("Failed to fork")
   
   if child_pid == 0:
      # we're the child...start the server
      rg_main.main( config, syndicate )
   
   return child_pid


#-------------------------------
def handle_child_death( pid, exit_status ):
   need_respawn = False
   
   # did the child exit on its own accord?
   if os.WIFEXITED(exit_status):
      log.info("RG exit status %s" % os.WEXITSTATUS( exit_status ) )
      need_respawn = False
   
   # was the child signaled? 
   elif os.WIFSIGNALED(exit_status):
      sig = os.WTERMSIG( exit_status )
      log.info("RG exited with signal %s" % sig )
      need_respawn = True
      
   return need_respawn


#-------------------------------
def kill_rg( child_pid ):
   # send SIGKILL
   log.info("Sending SIGKILL to RG...")
   os.kill( child_pid, signal.SIGKILL )

#-------------------------------
def stop_rg( child_pid ):
   # send SIGTERM, then SIGKILL
   log.info("Sending SIGTERM to RG...")
   os.kill( child_pid, signal.SIGTERM )
   
   count = 3
   while count > 0:
      try:
         pid, exit_status = os.waitpid( child_pid, os.WNOHANG )
      except OSError, e:
         log.exception(e)
         
         # if this wasn't ECHILD (i.e. the PID isn't invalid), then kill the process and die
         if e.errno != errno.ECHILD:
            kill_rg( child_pid )
            return -1
      
      # did it exit?
      if os.WIFEXITED(exit_status) or os.WIFSIGNALED(exit_status):
         break
      
      # if not, try again
      time.sleep(1.0)
      count -= 1

   if count == 0:
      kill_rg( child_pid )
      
   return 0
   

#-------------------------------
def main( config, syndicate ):
   
   # fork, become a watchdog, and run the main server
   child_pid = spawn_rg( config, syndicate )
   
   # we're the parent...start monitoring 
   while True:
      # wait for child to die
      try:
         pid, exit_status = os.waitpid( child_pid, 0 )
      except OSError, e:
         log.exception(e)
         sys.exit(1)
      except (KeyboardInterrupt, SystemExit):
         # kill the child and exit
         my_exit_status = stop_rg( child_pid )
         sys.exit(my_exit_status)
         
      need_respawn = handle_child_death( pid, exit_status )
      
      if need_respawn:
         child_pid = spawn_rg( config )
      
      else:
         sys.exit( os.WEXITSTATUS( exit_status ) )
         
   
#-------------------------------
if __name__ == "__main__":
   
   argv = sys.argv 
   
   config = rg_main.build_config( argv )
   syndicate = rg_main.setup_syndicate( config )
   
   # run in foreground?
   foreground = config['foreground']
   
   if not foreground:
      # become a daemon
      daemonize( config, syndicate, lambda: main(config, syndicate) )
   
   else:
      # run in the foreground
      main( config, syndicate )
      