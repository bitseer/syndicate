\section{Implementation}
\label{sec:implementation}

We implemented a prototype MS on top of Google AppEngine (GAE)~\cite{google-appengine}, which uses BigTable~\cite{bigtable} to provide a scalable indexed key/value store.\footnote{We also implemented an MS from scratch, but prefer the GAE-version for scalability reasons.} GAE is a cloud computing Platform-as-a-Service (PaaS) that dynamically scales up the number of running application processes to handle increasingly large request volumes. An application process in our case is a Python WSGI script that handles HTTP directives in GAE's threadsafe manner.

Our MS implementation stores the same information in each record as a typical UNIX i-node, plus the aforementioned \Syndicate-specific fields. The \texttt{owner} field indicates which UG is the acting owner, and the \texttt{mode} field indicates permissions for the acting owner UG (the user bits), the other Gateways in the Volume (the group bits), and the rest of the Internet (the world bits).

We implemented a UG prototype that exposes data through one of two interfaces. The first interface is a FUSE~\cite{FUSE} filesystem driver, which can be locally mounted. The second interface is a stateless HTTP server that interprets HTTP directives to create, delete, read, and write objects and directories. We think of these as two different UG instances that happen to share a significant amount of code (only the user-facing interface is different).

The UG stores object blocks as files on the host's local filesystem, where each block is named after its number and version. The UG keeps them under a local directory named after the object's identifier and its version, and organizes objects into a minimal spanning tree of ancestor directories on local storage. The UG interprets a read operation on an MS directory as a request for all of the MS records that identify the directory as their parent.

The UG lazily downloads and caches MS object and directory records by the path. When an object or directory is accessed, if any ancestor directory record is either stale or absent, the UG downloads the MS records for every directory and object on the path. Staleness is determined by each record's $\Delta_{read}$ value and the current time.

When the UG receives the path's metadata, it walks down the path and refreshes the cached directories starting from the root, and ending with the requested record. If an ancestor directory exists locally but not on the MS, and it existed before the access began, then the directory tree beneath the missing ancestor is unlinked and the access fails. If an ancestor directory does not exist locally but does on the MS, and the missing ancestor directory was unlinked before the refresh began, then it will be locally cached. If an ancestor directory has changed since the last refresh, it is marked as dirty.

If an application accesses a directory that is stale or was marked as dirty, the UG downloads and caches all MS records that identify the directory as their parent. The cached directory record is marked as clean after this refresh. This allows the UG to lazily discover \Syndicate\ objects on access, and lets the user group objects by how consistent they must be (i.e. by placing an object with stronger requirements into a directory with a small $\Delta_{read}$ value).

The FUSE UG handles truncates by atomically changing the version of the file on the MS, and then updating the manifest to add or remove blocks. This ensures that a remote write received shortly after a truncate will be negatively acknowledged, such that the remote writer UG will re-attempt the write after refreshing the file's metadata (acquiring its new version in the process).

Object and directory creation, update, deletion occurs either synchronously or asynchronously, which is controlled by an additional $\Delta_{writeback}$ field in the i-node. If this value is zero, then it is synchronous. Otherwise, the UG optimistically executes the operation locally, and places a request in a global priority queue to be sent after $\Delta_{writeback}$ milliseconds. If the operation fails on the MS, the local change is reverted. Update messages for the same object are merged when they are enqueued.

Blocks and manifests are replicated to RGs synchronously by the FUSE UG if the object's file descriptor was opened for synchronous I/O. Otherwise, replication is asynchronous with respect to writes, but guaranteed to finish before the \texttt{close()} operation returns. Â In either case, manifests are replicated after blocks, and modification times are posted to the MS after manifests are replicated. The \texttt{fsync()} syscall causes the FUSE UG to block the caller until all pending replicas and metadata updates on the given object have completed. This lets the user trade write performance for write durability in an application-specific manner.

The FUSE UG exposes \Syndicate-specific metadata fields through the POSIX extended attribute interface. The HTTP object store UG exposes them through extra HTTP headers in a response.

We implemented a simple RG that stores blocks and manifests as local files, and an RG that stores blocks and manifests in Amazon S3~\cite{S3} storage. We implemented a simple AG that exposes a local filesystem hierarchy as objects under a user-chosen directory in the MS. Both RGs and AGs interact with the other players in a \Syndicate\ volume (e.g., serve blocks and manifests) in exactly the same way as a UG.
