#!/usr/bin/env python

"""
   Copyright 2013 The Trustees of Princeton University
   All Rights Reserved
"""

# stubs for all Syndicate objects

import msconfig
from msconfig import *
import api
import inspect
import re 

# RFC-822 compliant, as long as there aren't any comments in the address.
# taken from http://chrisbailey.blogs.ilrt.org/2013/08/19/validating-email-addresses-in-python/
email_regex_str = r"^(?=^.{1,256}$)(?=.{1,64}@)(?:[^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22(?:[^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22)(?:\x2e(?:[^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22(?:[^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22))*\x40(?:[^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|[\x5b](?:[^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*[\x5d])(?:\x2e(?:[^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|[\x5b](?:[^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*[\x5d]))*$"

email_regex = re.compile( email_regex_str )

class StubObject:
   def __init__(self, *args, **kw):
      pass
   
   @classmethod
   def Authenticate( cls, *args, **kw ):
      pass
   
   @classmethod
   def Sign( cls, *args, **kw ):
      pass

   @classmethod
   def parse_or_generate_signing_public_key( cls, signing_public_key ):
      extra = {}
      
      if signing_public_key == "MAKE_SIGNING_KEY":
         pubkey_pem, privkey_pem = api.generate_key_pair( OBJECT_KEY_SIZE )
         extra['signing_public_key'] = pubkey_pem
         extra['signing_private_key'] = privkey_pem
         
         signing_public_key = pubkey_pem
      
      else:
         # try validating the given one
         try:
            pubkey = CryptoKey.importKey( signing_public_key )
         except Exception, e:
            logging.exception(e)
            raise Exception("Failed to parse public key")
         
      return signing_public_key, extra
   
   
   @classmethod
   def parse_or_generate_private_key( cls, pkey_str, pkey_arg_name, key_size ):
      if pkey_str == pkey_arg_name:
         # generate one
         pubkey_str, pkey_str = api.generate_key_pair( key_size )
         return pubkey_str, pkey_str
      
      else:
         # validate a given one
         try:
            pkey = CryptoKey.importKey( pkey_str )
         except Exception, e:
            logging.exception(e)
            raise Exception("Failed to parse private key")
         
         # is it the right size?
         if pkey.size() != key_size - 1:
            raise Exception("Private key has %s bits; expected %s bits" % (pkey.size() + 1, key_size))
         
         return pkey.publickey().exportKey(), pkey_str
   
   @classmethod
   def parse_gateway_caps( cls, caps_str ):
      flags = caps_str.split("|")
      ret = 0
      
      for flag in flags:
         value = getattr( msconfig, flag, 0 )
         if value == 0:
            raise Exception("Unknown Gateway capability '%s'" % flag)
         
         try:
            ret |= value
         except:
            raise Exception("Invalid value '%s'" % value)
      
      return ret, {}
   
   
   # map str to func
   arg_parsers = {
      "signing_public_key": (lambda cls, arg: cls.parse_or_generate_signing_public_key(arg))
   }
   
   # key type
   key_type = None
   
   # key directory 
   key_dir = None
   
   # key types
   key_types = [
      "signing",
      "verifying"
   ]
   
   @classmethod
   def ParseArgs( cls, argspec, args, kw ):
      """
      Insert arguments and keywords from commandline-given arguments.
      Return the new args and kw, as well as a dict of extra information 
      generated by the arg parser that the caller might want to know.
      This method walks the arg_parsers class method.
      """
      extras_all = {}
      for arg_name, arg_func in cls.arg_parsers.items():
         args, kw, extras = cls.ReplaceArg( argspec, arg_name, arg_func, args, kw )
         extras_all.update( extras )
      
      return args, kw, extras_all
   
   @classmethod
   def ReplaceArg( cls, argspec, arg_name, arg_value_func, args, kw ):
      
      # find positional argument?
      args = list(args)
      extras = {}
      
      for i in xrange(0, min(len(args), len(argspec.args))):
         if argspec.args[i] == arg_name:
            args[i], arg_extras = arg_value_func( cls, args[i] )
            extras.update( arg_extras )
      
      # find keyword argument?
      if arg_name in kw.keys():
         kw[arg_name], arg_extras = arg_value_func( cls, kw[arg_name] )
         extras.update( arg_extras )
         
      return (args, kw, extras)
         
         
         
         
         
   
class SyndicateUser( StubObject ):
   @classmethod
   def parse_user_name_or_id( cls, user_name_or_id ):
      # only accept emails
      try:
         user_id = int(user_name_or_id)
      except:
         if not email_regex.match(user_name_or_id):
            raise Exception("Not an email address: '%s'" % user_name_or_id)
         else:
            return user_name_or_id, {}
      
      raise Exception("Parse error: only user emails (not IDs) are allowed")
   
   
   arg_parsers = dict( StubObject.arg_parsers.items() + {
      "email": (lambda cls, arg: cls.parse_user_name_or_id(arg))
   }.items() )
   
   key_type = "user"
   
   key_dir = "user_keys"
            
            
            
            

class Volume( StubObject ):
   
   @classmethod
   def parse_volume_name_or_id( cls, volume_name_or_id ):
      # only accept names...
      try:
         vid = int(volume_name_or_id)
      except:
         return volume_name_or_id, {}
      
      raise Exception("Parse error: Only volume names (not IDs) are allowed")


   @classmethod
   def parse_metadata_private_key( cls, metadata_private_key ):
      pubkey, privkey = cls.parse_or_generate_private_key( metadata_private_key, "MAKE_METADATA_KEY", OBJECT_KEY_SIZE )
      extra = {'metadata_public_key': pubkey}
      
      return privkey, extra

   arg_parsers = dict( StubObject.arg_parsers.items() + {
      "volume_name_or_id":      (lambda cls, arg: cls.parse_volume_name_or_id(arg)),
      "metadata_private_key":   (lambda cls, arg: cls.parse_metadata_private_key(arg)),
      "default_gateway_caps":   (lambda cls, arg: cls.parse_gateway_caps(arg))
   }.items() )
   
   key_type = "volume"
   
   key_dir = "volume_keys"
   
   key_types = StubObject.key_types + [
      "metadata"
   ]
   




class Gateway( StubObject ):
   @classmethod
   def parse_gateway_name_or_id( cls, gateway_name_or_id ):
      # only accept names...
      try:
         vid = int(gateway_name_or_id)
      except:
         return gateway_name_or_id, {}
      
      raise Exception("Parse error: Only Gateway names (not IDs) are allowed")

      
   @classmethod
   def parse_gateway_type( cls, type_str ):
      if type_str == "UG":
         return GATEWAY_TYPE_UG, {}
      elif type_str == "RG":
         return GATEWAY_TYPE_RG, {}
      elif type_str == "AG":
         return GATEWAY_TYPE_AG, {}
      
      raise Exception("Unknown Gateway type '%s'" % type_str)
   
   @classmethod
   def parse_gateway_public_key( cls, gateway_private_key ):
      pubkey, privkey = cls.parse_or_generate_private_key( gateway_private_key, "MAKE_GATEWAY_KEY", OBJECT_KEY_SIZE )
      extra = {'gateway_private_key': privkey}
      
      return pubkey, extra
   
   arg_parsers = dict( StubObject.arg_parsers.items() + {
      "g_name_or_id":           (lambda cls, arg: cls.parse_gateway_name_or_id(arg)),
      "caps":                   (lambda cls, arg: cls.parse_gateway_caps(arg)),
      "gateway_type":           (lambda cls, arg: cls.parse_gateway_type(arg)),
      "gateway_public_key":     (lambda cls, arg: cls.parse_gateway_public_key(arg))
   }.items() )
   
   key_type = "gateway"
   
   key_dir = "gateway_keys"
   
   key_types = StubObject.key_types + [
      "runtime"
   ]





class VolumeAccessRequest( StubObject ):
   pass

