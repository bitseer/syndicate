#!/usr/bin/env python

import webapp2
import urlparse

import MS
from MS.volume import Volume
from MS.entry import *

import protobufs.ms_pb2 as ms_pb2

from storage import storage

import tests

import random
import os


class MSRequestHandler(webapp2.RequestHandler):

   functions = [
      "VOLUME"
      "FILE"
   ]

   def parse_path( self, path_info ):
      """
      Given a PATH_INFO from the WSGI environment,
      determine what the request is for.
         format:
            volume_id/operation/path

         function: volume_id
         volume_id: int

         if feature == volume_id:
            operation: "REPLICAS" | "FILE" | "USERS" | "VOLUMEID" | "BLOCKSIZE"
            path: str

         if feature == "admin":
            operation: null

         if feature == "debug":
            operation: test_name
            test_name: str
      """
      try:
         parsed = urlparse.urlparse( path_info )
         path = parsed.path
         parts = path.split( "/" )
         
         volume_id = int( parts[0] )
         function = parts[1]
         if function not in self.functions:
            raise Exception("Invalid function '%s'" % function)

         path = "/".join( parts[2:] )

         return (volume_id, function, path)
      except:
         return (None, None, None)


   def handle_request( self, user, volume, function, path ):
      """
      Given a volume and object string, see if it refers to some volume metadata.
      If so, get the metadata and write it out.

      Return True if handled, False if not; None if error
      """
      if function == "REPLICAS":
         # request for replica gateway URLs
         for replica_key in volume.replica_keys:
            replica_gateway = replica_key.get()
            if replica_gateway == None:
               continue

            self.response.write( replica_gateway.url + "\n" )

         self.response.status = 200

         # handled!
         return True

      if function == "FILE":
         # request for a path's worth of metadata
         reply = self.resolve( None, user, volume, path )

         self.response.status = 200
         self.response.write( reply.SerializeToString() )

         return True

      # not handled
      return False


   def read_path_metadata( self, owner_id, volume_id, fs_path ):
      """
      Read a path's worth of metadata from the volume.
      Return a list of path entries, and a list of children path entries (or None of the path refers to a file)
      """

      ent_metadata = storage.read_msentry_path( volume_id, fs_path )

      children_metadata = None
      valid = True

      # validate consistency and permissions on the directories leading to the base
      # (avoid querying children if we can)
      for i in xrange(0,len(ent_metadata)):
         ent = ent_metadata[i]

         if ent == None:
            # path refers to some nonexistant data
            ent_metadata = ent_metadata[:i]
            break

         # this must be a directory
         if ent.ftype != MSENTRY_TYPE_DIR:
            # not consistent
            valid = False
            ent_metadata = ent_metadata[:i]
            break

         # this must be searchable
         if ent.owner_id != owner_id and (ent.mode & 0011) == 0:
            # not searchable
            valid = False
            ent_metadata = ent_metadata[:i]
            break


      if valid:
         # got back valid, readable metadata.
         # did we get back the entry at the base?
         path_len = len( fs_path.split("/") )
         if len( ent_metadata ) == path_len:
            # yup
            base_ent = ent_metadata[-1]

            # if it's a directory, and we can read it, read its children
            if base_ent.ftype == MSENTRY_TYPE_DIR and (base_ent.owner_id == owner_id or (base_ent.mode & 0044) != 0):
               children_metadata = storage.read_msentry_children( volume_id, fs_path, base_ent.num_children )

      return (ent_metadata, children_metadata)



   def resolve( self, user, volume, fs_path ):
      """
      Given a user, volume, and an absolute filesystem path, resolve the path into an ms_reply message.
      Return a serialized response
      """

      # get the metadata
      path_metadata, children_metadata = self.read_path_metadata( user.owner_id, volume.volume_id, fs_path )


      # serialize
      reply = ms_pb2.ms_reply()

      reply.id = random.getrandbits( 64 )

      for ent_dir in path_metadata:
         if ent_dir != None:
            reply.entries_dir.append( ent_dir.protobuf() )
         else:
            break

      if found:
         for ent_base in ent_metadata:
            reply.entries_base.append( ent_base.protobuf() )

      return reply.SerializeToString()


   def get( self, _path ):
      # interpret the request
      volume_id, function, path = self.parse_path( _path )
      if volume_id == None or function == None:
         # invalid
         self.response.status = 400
         self.response.write("Invalid request")
         return
      
      # request to a volume.  Look up the volume
      volume = storage.read_volume( volume_id )
      if volume == None:
         # no volume
         self.response.status = 404
         self.response.write("No such volume")
         return

      # get the user
      user = None
      
      ret = self.handle_request( self, user, volume, function, path )
      if ret == None:
         # error
         self.response.status = 500
         self.response.write("Intenral Server Error")
         return

      elif ret == True:
         # already handled
         return

      else:
         # could not handle
         self.response.status = 501
         self.response.write("Method Not Implemented")
         return


   def put(self):
       pass

       