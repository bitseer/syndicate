// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ms.proto

#ifndef PROTOBUF_ms_2eproto__INCLUDED
#define PROTOBUF_ms_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace ms {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ms_2eproto();
void protobuf_AssignDesc_ms_2eproto();
void protobuf_ShutdownFile_ms_2eproto();

class ms_entry;
class ms_update;
class ms_updates;
class ms_reply;
class ms_gateway_blockinfo;
class ms_volume_gateway_cred;
class ms_volume_metadata;

enum ms_entry_FileType {
  ms_entry_FileType_MS_ENTRY_TYPE_FILE = 1,
  ms_entry_FileType_MS_ENTRY_TYPE_DIR = 2
};
bool ms_entry_FileType_IsValid(int value);
const ms_entry_FileType ms_entry_FileType_FileType_MIN = ms_entry_FileType_MS_ENTRY_TYPE_FILE;
const ms_entry_FileType ms_entry_FileType_FileType_MAX = ms_entry_FileType_MS_ENTRY_TYPE_DIR;
const int ms_entry_FileType_FileType_ARRAYSIZE = ms_entry_FileType_FileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ms_entry_FileType_descriptor();
inline const ::std::string& ms_entry_FileType_Name(ms_entry_FileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ms_entry_FileType_descriptor(), value);
}
inline bool ms_entry_FileType_Parse(
    const ::std::string& name, ms_entry_FileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ms_entry_FileType>(
    ms_entry_FileType_descriptor(), name, value);
}
enum ms_update_UpdateType {
  ms_update_UpdateType_CREATE = 1,
  ms_update_UpdateType_UPDATE = 2,
  ms_update_UpdateType_DELETE = 3
};
bool ms_update_UpdateType_IsValid(int value);
const ms_update_UpdateType ms_update_UpdateType_UpdateType_MIN = ms_update_UpdateType_CREATE;
const ms_update_UpdateType ms_update_UpdateType_UpdateType_MAX = ms_update_UpdateType_DELETE;
const int ms_update_UpdateType_UpdateType_ARRAYSIZE = ms_update_UpdateType_UpdateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ms_update_UpdateType_descriptor();
inline const ::std::string& ms_update_UpdateType_Name(ms_update_UpdateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ms_update_UpdateType_descriptor(), value);
}
inline bool ms_update_UpdateType_Parse(
    const ::std::string& name, ms_update_UpdateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ms_update_UpdateType>(
    ms_update_UpdateType_descriptor(), name, value);
}
enum ms_gateway_blockinfo_ProgressType {
  ms_gateway_blockinfo_ProgressType_STARTED = 1,
  ms_gateway_blockinfo_ProgressType_COMMITTED = 2
};
bool ms_gateway_blockinfo_ProgressType_IsValid(int value);
const ms_gateway_blockinfo_ProgressType ms_gateway_blockinfo_ProgressType_ProgressType_MIN = ms_gateway_blockinfo_ProgressType_STARTED;
const ms_gateway_blockinfo_ProgressType ms_gateway_blockinfo_ProgressType_ProgressType_MAX = ms_gateway_blockinfo_ProgressType_COMMITTED;
const int ms_gateway_blockinfo_ProgressType_ProgressType_ARRAYSIZE = ms_gateway_blockinfo_ProgressType_ProgressType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ms_gateway_blockinfo_ProgressType_descriptor();
inline const ::std::string& ms_gateway_blockinfo_ProgressType_Name(ms_gateway_blockinfo_ProgressType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ms_gateway_blockinfo_ProgressType_descriptor(), value);
}
inline bool ms_gateway_blockinfo_ProgressType_Parse(
    const ::std::string& name, ms_gateway_blockinfo_ProgressType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ms_gateway_blockinfo_ProgressType>(
    ms_gateway_blockinfo_ProgressType_descriptor(), name, value);
}
// ===================================================================

class ms_entry : public ::google::protobuf::Message {
 public:
  ms_entry();
  virtual ~ms_entry();
  
  ms_entry(const ms_entry& from);
  
  inline ms_entry& operator=(const ms_entry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ms_entry& default_instance();
  
  void Swap(ms_entry* other);
  
  // implements Message ----------------------------------------------
  
  ms_entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ms_entry& from);
  void MergeFrom(const ms_entry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ms_entry_FileType FileType;
  static const FileType MS_ENTRY_TYPE_FILE = ms_entry_FileType_MS_ENTRY_TYPE_FILE;
  static const FileType MS_ENTRY_TYPE_DIR = ms_entry_FileType_MS_ENTRY_TYPE_DIR;
  static inline bool FileType_IsValid(int value) {
    return ms_entry_FileType_IsValid(value);
  }
  static const FileType FileType_MIN =
    ms_entry_FileType_FileType_MIN;
  static const FileType FileType_MAX =
    ms_entry_FileType_FileType_MAX;
  static const int FileType_ARRAYSIZE =
    ms_entry_FileType_FileType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FileType_descriptor() {
    return ms_entry_FileType_descriptor();
  }
  static inline const ::std::string& FileType_Name(FileType value) {
    return ms_entry_FileType_Name(value);
  }
  static inline bool FileType_Parse(const ::std::string& name,
      FileType* value) {
    return ms_entry_FileType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required int64 ctime_sec = 2;
  inline bool has_ctime_sec() const;
  inline void clear_ctime_sec();
  static const int kCtimeSecFieldNumber = 2;
  inline ::google::protobuf::int64 ctime_sec() const;
  inline void set_ctime_sec(::google::protobuf::int64 value);
  
  // required int64 ctime_nsec = 3;
  inline bool has_ctime_nsec() const;
  inline void clear_ctime_nsec();
  static const int kCtimeNsecFieldNumber = 3;
  inline ::google::protobuf::int64 ctime_nsec() const;
  inline void set_ctime_nsec(::google::protobuf::int64 value);
  
  // required int64 mtime_sec = 4;
  inline bool has_mtime_sec() const;
  inline void clear_mtime_sec();
  static const int kMtimeSecFieldNumber = 4;
  inline ::google::protobuf::int64 mtime_sec() const;
  inline void set_mtime_sec(::google::protobuf::int64 value);
  
  // required int32 mtime_nsec = 5;
  inline bool has_mtime_nsec() const;
  inline void clear_mtime_nsec();
  static const int kMtimeNsecFieldNumber = 5;
  inline ::google::protobuf::int32 mtime_nsec() const;
  inline void set_mtime_nsec(::google::protobuf::int32 value);
  
  // required int32 owner = 6;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 6;
  inline ::google::protobuf::int32 owner() const;
  inline void set_owner(::google::protobuf::int32 value);
  
  // required int32 volume = 7;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 7;
  inline ::google::protobuf::int32 volume() const;
  inline void set_volume(::google::protobuf::int32 value);
  
  // required int32 mode = 8;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 8;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);
  
  // required uint64 size = 9;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 9;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);
  
  // required int64 version = 10;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 10;
  inline ::google::protobuf::int64 version() const;
  inline void set_version(::google::protobuf::int64 value);
  
  // required int32 max_read_freshness = 11;
  inline bool has_max_read_freshness() const;
  inline void clear_max_read_freshness();
  static const int kMaxReadFreshnessFieldNumber = 11;
  inline ::google::protobuf::int32 max_read_freshness() const;
  inline void set_max_read_freshness(::google::protobuf::int32 value);
  
  // required int32 max_write_freshness = 12;
  inline bool has_max_write_freshness() const;
  inline void clear_max_write_freshness();
  static const int kMaxWriteFreshnessFieldNumber = 12;
  inline ::google::protobuf::int32 max_write_freshness() const;
  inline void set_max_write_freshness(::google::protobuf::int32 value);
  
  // required string path = 13;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 13;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // required string url = 14;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 14;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // @@protoc_insertion_point(class_scope:ms.ms_entry)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ctime_sec();
  inline void clear_has_ctime_sec();
  inline void set_has_ctime_nsec();
  inline void clear_has_ctime_nsec();
  inline void set_has_mtime_sec();
  inline void clear_has_mtime_sec();
  inline void set_has_mtime_nsec();
  inline void clear_has_mtime_nsec();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_max_read_freshness();
  inline void clear_has_max_read_freshness();
  inline void set_has_max_write_freshness();
  inline void clear_has_max_write_freshness();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_url();
  inline void clear_has_url();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 ctime_sec_;
  ::google::protobuf::int64 ctime_nsec_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 mtime_nsec_;
  ::google::protobuf::int64 mtime_sec_;
  ::google::protobuf::int32 owner_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int32 max_read_freshness_;
  ::google::protobuf::int64 version_;
  ::std::string* path_;
  ::std::string* url_;
  ::google::protobuf::int32 max_write_freshness_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_ms_2eproto();
  friend void protobuf_AssignDesc_ms_2eproto();
  friend void protobuf_ShutdownFile_ms_2eproto();
  
  void InitAsDefaultInstance();
  static ms_entry* default_instance_;
};
// -------------------------------------------------------------------

class ms_update : public ::google::protobuf::Message {
 public:
  ms_update();
  virtual ~ms_update();
  
  ms_update(const ms_update& from);
  
  inline ms_update& operator=(const ms_update& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ms_update& default_instance();
  
  void Swap(ms_update* other);
  
  // implements Message ----------------------------------------------
  
  ms_update* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ms_update& from);
  void MergeFrom(const ms_update& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ms_update_UpdateType UpdateType;
  static const UpdateType CREATE = ms_update_UpdateType_CREATE;
  static const UpdateType UPDATE = ms_update_UpdateType_UPDATE;
  static const UpdateType DELETE = ms_update_UpdateType_DELETE;
  static inline bool UpdateType_IsValid(int value) {
    return ms_update_UpdateType_IsValid(value);
  }
  static const UpdateType UpdateType_MIN =
    ms_update_UpdateType_UpdateType_MIN;
  static const UpdateType UpdateType_MAX =
    ms_update_UpdateType_UpdateType_MAX;
  static const int UpdateType_ARRAYSIZE =
    ms_update_UpdateType_UpdateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UpdateType_descriptor() {
    return ms_update_UpdateType_descriptor();
  }
  static inline const ::std::string& UpdateType_Name(UpdateType value) {
    return ms_update_UpdateType_Name(value);
  }
  static inline bool UpdateType_Parse(const ::std::string& name,
      UpdateType* value) {
    return ms_update_UpdateType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required .ms.ms_entry entry = 2;
  inline bool has_entry() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 2;
  inline const ::ms::ms_entry& entry() const;
  inline ::ms::ms_entry* mutable_entry();
  inline ::ms::ms_entry* release_entry();
  
  // @@protoc_insertion_point(class_scope:ms.ms_update)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_entry();
  inline void clear_has_entry();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ms::ms_entry* entry_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ms_2eproto();
  friend void protobuf_AssignDesc_ms_2eproto();
  friend void protobuf_ShutdownFile_ms_2eproto();
  
  void InitAsDefaultInstance();
  static ms_update* default_instance_;
};
// -------------------------------------------------------------------

class ms_updates : public ::google::protobuf::Message {
 public:
  ms_updates();
  virtual ~ms_updates();
  
  ms_updates(const ms_updates& from);
  
  inline ms_updates& operator=(const ms_updates& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ms_updates& default_instance();
  
  void Swap(ms_updates* other);
  
  // implements Message ----------------------------------------------
  
  ms_updates* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ms_updates& from);
  void MergeFrom(const ms_updates& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ms.ms_update updates = 1;
  inline int updates_size() const;
  inline void clear_updates();
  static const int kUpdatesFieldNumber = 1;
  inline const ::ms::ms_update& updates(int index) const;
  inline ::ms::ms_update* mutable_updates(int index);
  inline ::ms::ms_update* add_updates();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::ms_update >&
      updates() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::ms_update >*
      mutable_updates();
  
  // @@protoc_insertion_point(class_scope:ms.ms_updates)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ms::ms_update > updates_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ms_2eproto();
  friend void protobuf_AssignDesc_ms_2eproto();
  friend void protobuf_ShutdownFile_ms_2eproto();
  
  void InitAsDefaultInstance();
  static ms_updates* default_instance_;
};
// -------------------------------------------------------------------

class ms_reply : public ::google::protobuf::Message {
 public:
  ms_reply();
  virtual ~ms_reply();
  
  ms_reply(const ms_reply& from);
  
  inline ms_reply& operator=(const ms_reply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ms_reply& default_instance();
  
  void Swap(ms_reply* other);
  
  // implements Message ----------------------------------------------
  
  ms_reply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ms_reply& from);
  void MergeFrom(const ms_reply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 volume_version = 1;
  inline bool has_volume_version() const;
  inline void clear_volume_version();
  static const int kVolumeVersionFieldNumber = 1;
  inline ::google::protobuf::int64 volume_version() const;
  inline void set_volume_version(::google::protobuf::int64 value);
  
  // repeated .ms.ms_entry entries_dir = 2;
  inline int entries_dir_size() const;
  inline void clear_entries_dir();
  static const int kEntriesDirFieldNumber = 2;
  inline const ::ms::ms_entry& entries_dir(int index) const;
  inline ::ms::ms_entry* mutable_entries_dir(int index);
  inline ::ms::ms_entry* add_entries_dir();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::ms_entry >&
      entries_dir() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::ms_entry >*
      mutable_entries_dir();
  
  // repeated .ms.ms_entry entries_base = 3;
  inline int entries_base_size() const;
  inline void clear_entries_base();
  static const int kEntriesBaseFieldNumber = 3;
  inline const ::ms::ms_entry& entries_base(int index) const;
  inline ::ms::ms_entry* mutable_entries_base(int index);
  inline ::ms::ms_entry* add_entries_base();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::ms_entry >&
      entries_base() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::ms_entry >*
      mutable_entries_base();
  
  // required int32 error = 4;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 4;
  inline ::google::protobuf::int32 error() const;
  inline void set_error(::google::protobuf::int32 value);
  
  // optional string errormsg = 5;
  inline bool has_errormsg() const;
  inline void clear_errormsg();
  static const int kErrormsgFieldNumber = 5;
  inline const ::std::string& errormsg() const;
  inline void set_errormsg(const ::std::string& value);
  inline void set_errormsg(const char* value);
  inline void set_errormsg(const char* value, size_t size);
  inline ::std::string* mutable_errormsg();
  inline ::std::string* release_errormsg();
  
  // @@protoc_insertion_point(class_scope:ms.ms_reply)
 private:
  inline void set_has_volume_version();
  inline void clear_has_volume_version();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_errormsg();
  inline void clear_has_errormsg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 volume_version_;
  ::google::protobuf::RepeatedPtrField< ::ms::ms_entry > entries_dir_;
  ::google::protobuf::RepeatedPtrField< ::ms::ms_entry > entries_base_;
  ::std::string* errormsg_;
  ::google::protobuf::int32 error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ms_2eproto();
  friend void protobuf_AssignDesc_ms_2eproto();
  friend void protobuf_ShutdownFile_ms_2eproto();
  
  void InitAsDefaultInstance();
  static ms_reply* default_instance_;
};
// -------------------------------------------------------------------

class ms_gateway_blockinfo : public ::google::protobuf::Message {
 public:
  ms_gateway_blockinfo();
  virtual ~ms_gateway_blockinfo();
  
  ms_gateway_blockinfo(const ms_gateway_blockinfo& from);
  
  inline ms_gateway_blockinfo& operator=(const ms_gateway_blockinfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ms_gateway_blockinfo& default_instance();
  
  void Swap(ms_gateway_blockinfo* other);
  
  // implements Message ----------------------------------------------
  
  ms_gateway_blockinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ms_gateway_blockinfo& from);
  void MergeFrom(const ms_gateway_blockinfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ms_gateway_blockinfo_ProgressType ProgressType;
  static const ProgressType STARTED = ms_gateway_blockinfo_ProgressType_STARTED;
  static const ProgressType COMMITTED = ms_gateway_blockinfo_ProgressType_COMMITTED;
  static inline bool ProgressType_IsValid(int value) {
    return ms_gateway_blockinfo_ProgressType_IsValid(value);
  }
  static const ProgressType ProgressType_MIN =
    ms_gateway_blockinfo_ProgressType_ProgressType_MIN;
  static const ProgressType ProgressType_MAX =
    ms_gateway_blockinfo_ProgressType_ProgressType_MAX;
  static const int ProgressType_ARRAYSIZE =
    ms_gateway_blockinfo_ProgressType_ProgressType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProgressType_descriptor() {
    return ms_gateway_blockinfo_ProgressType_descriptor();
  }
  static inline const ::std::string& ProgressType_Name(ProgressType value) {
    return ms_gateway_blockinfo_ProgressType_Name(value);
  }
  static inline bool ProgressType_Parse(const ::std::string& name,
      ProgressType* value) {
    return ms_gateway_blockinfo_ProgressType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string fs_path = 10;
  inline bool has_fs_path() const;
  inline void clear_fs_path();
  static const int kFsPathFieldNumber = 10;
  inline const ::std::string& fs_path() const;
  inline void set_fs_path(const ::std::string& value);
  inline void set_fs_path(const char* value);
  inline void set_fs_path(const char* value, size_t size);
  inline ::std::string* mutable_fs_path();
  inline ::std::string* release_fs_path();
  
  // required int64 file_version = 1;
  inline bool has_file_version() const;
  inline void clear_file_version();
  static const int kFileVersionFieldNumber = 1;
  inline ::google::protobuf::int64 file_version() const;
  inline void set_file_version(::google::protobuf::int64 value);
  
  // required uint64 block_id = 2;
  inline bool has_block_id() const;
  inline void clear_block_id();
  static const int kBlockIdFieldNumber = 2;
  inline ::google::protobuf::uint64 block_id() const;
  inline void set_block_id(::google::protobuf::uint64 value);
  
  // required int64 block_version = 3;
  inline bool has_block_version() const;
  inline void clear_block_version();
  static const int kBlockVersionFieldNumber = 3;
  inline ::google::protobuf::int64 block_version() const;
  inline void set_block_version(::google::protobuf::int64 value);
  
  // required uint64 blocking_factor = 4;
  inline bool has_blocking_factor() const;
  inline void clear_blocking_factor();
  static const int kBlockingFactorFieldNumber = 4;
  inline ::google::protobuf::uint64 blocking_factor() const;
  inline void set_blocking_factor(::google::protobuf::uint64 value);
  
  // required int64 file_mtime_sec = 5;
  inline bool has_file_mtime_sec() const;
  inline void clear_file_mtime_sec();
  static const int kFileMtimeSecFieldNumber = 5;
  inline ::google::protobuf::int64 file_mtime_sec() const;
  inline void set_file_mtime_sec(::google::protobuf::int64 value);
  
  // required int32 file_mtime_nsec = 6;
  inline bool has_file_mtime_nsec() const;
  inline void clear_file_mtime_nsec();
  static const int kFileMtimeNsecFieldNumber = 6;
  inline ::google::protobuf::int32 file_mtime_nsec() const;
  inline void set_file_mtime_nsec(::google::protobuf::int32 value);
  
  // optional int32 progress = 7;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 7;
  inline ::google::protobuf::int32 progress() const;
  inline void set_progress(::google::protobuf::int32 value);
  
  // optional int64 write_time = 8;
  inline bool has_write_time() const;
  inline void clear_write_time();
  static const int kWriteTimeFieldNumber = 8;
  inline ::google::protobuf::int64 write_time() const;
  inline void set_write_time(::google::protobuf::int64 value);
  
  // optional int64 session_id = 9;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 9;
  inline ::google::protobuf::int64 session_id() const;
  inline void set_session_id(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:ms.ms_gateway_blockinfo)
 private:
  inline void set_has_fs_path();
  inline void clear_has_fs_path();
  inline void set_has_file_version();
  inline void clear_has_file_version();
  inline void set_has_block_id();
  inline void clear_has_block_id();
  inline void set_has_block_version();
  inline void clear_has_block_version();
  inline void set_has_blocking_factor();
  inline void clear_has_blocking_factor();
  inline void set_has_file_mtime_sec();
  inline void clear_has_file_mtime_sec();
  inline void set_has_file_mtime_nsec();
  inline void clear_has_file_mtime_nsec();
  inline void set_has_progress();
  inline void clear_has_progress();
  inline void set_has_write_time();
  inline void clear_has_write_time();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* fs_path_;
  ::google::protobuf::int64 file_version_;
  ::google::protobuf::uint64 block_id_;
  ::google::protobuf::int64 block_version_;
  ::google::protobuf::uint64 blocking_factor_;
  ::google::protobuf::int64 file_mtime_sec_;
  ::google::protobuf::int32 file_mtime_nsec_;
  ::google::protobuf::int32 progress_;
  ::google::protobuf::int64 write_time_;
  ::google::protobuf::int64 session_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_ms_2eproto();
  friend void protobuf_AssignDesc_ms_2eproto();
  friend void protobuf_ShutdownFile_ms_2eproto();
  
  void InitAsDefaultInstance();
  static ms_gateway_blockinfo* default_instance_;
};
// -------------------------------------------------------------------

class ms_volume_gateway_cred : public ::google::protobuf::Message {
 public:
  ms_volume_gateway_cred();
  virtual ~ms_volume_gateway_cred();
  
  ms_volume_gateway_cred(const ms_volume_gateway_cred& from);
  
  inline ms_volume_gateway_cred& operator=(const ms_volume_gateway_cred& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ms_volume_gateway_cred& default_instance();
  
  void Swap(ms_volume_gateway_cred* other);
  
  // implements Message ----------------------------------------------
  
  ms_volume_gateway_cred* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ms_volume_gateway_cred& from);
  void MergeFrom(const ms_volume_gateway_cred& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 owner_id = 1;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 1;
  inline ::google::protobuf::int32 owner_id() const;
  inline void set_owner_id(::google::protobuf::int32 value);
  
  // required string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string password_hash = 3;
  inline bool has_password_hash() const;
  inline void clear_password_hash();
  static const int kPasswordHashFieldNumber = 3;
  inline const ::std::string& password_hash() const;
  inline void set_password_hash(const ::std::string& value);
  inline void set_password_hash(const char* value);
  inline void set_password_hash(const char* value, size_t size);
  inline ::std::string* mutable_password_hash();
  inline ::std::string* release_password_hash();
  
  // @@protoc_insertion_point(class_scope:ms.ms_volume_gateway_cred)
 private:
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password_hash();
  inline void clear_has_password_hash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::std::string* password_hash_;
  ::google::protobuf::int32 owner_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ms_2eproto();
  friend void protobuf_AssignDesc_ms_2eproto();
  friend void protobuf_ShutdownFile_ms_2eproto();
  
  void InitAsDefaultInstance();
  static ms_volume_gateway_cred* default_instance_;
};
// -------------------------------------------------------------------

class ms_volume_metadata : public ::google::protobuf::Message {
 public:
  ms_volume_metadata();
  virtual ~ms_volume_metadata();
  
  ms_volume_metadata(const ms_volume_metadata& from);
  
  inline ms_volume_metadata& operator=(const ms_volume_metadata& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ms_volume_metadata& default_instance();
  
  void Swap(ms_volume_metadata* other);
  
  // implements Message ----------------------------------------------
  
  ms_volume_metadata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ms_volume_metadata& from);
  void MergeFrom(const ms_volume_metadata& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 blocksize = 1;
  inline bool has_blocksize() const;
  inline void clear_blocksize();
  static const int kBlocksizeFieldNumber = 1;
  inline ::google::protobuf::uint64 blocksize() const;
  inline void set_blocksize(::google::protobuf::uint64 value);
  
  // required uint64 requester_id = 2;
  inline bool has_requester_id() const;
  inline void clear_requester_id();
  static const int kRequesterIdFieldNumber = 2;
  inline ::google::protobuf::uint64 requester_id() const;
  inline void set_requester_id(::google::protobuf::uint64 value);
  
  // required uint64 owner_id = 3;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 3;
  inline ::google::protobuf::uint64 owner_id() const;
  inline void set_owner_id(::google::protobuf::uint64 value);
  
  // required uint64 volume_id = 4;
  inline bool has_volume_id() const;
  inline void clear_volume_id();
  static const int kVolumeIdFieldNumber = 4;
  inline ::google::protobuf::uint64 volume_id() const;
  inline void set_volume_id(::google::protobuf::uint64 value);
  
  // required uint64 volume_version = 5;
  inline bool has_volume_version() const;
  inline void clear_volume_version();
  static const int kVolumeVersionFieldNumber = 5;
  inline ::google::protobuf::uint64 volume_version() const;
  inline void set_volume_version(::google::protobuf::uint64 value);
  
  // required string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string description = 7;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 7;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // repeated string replica_urls = 8;
  inline int replica_urls_size() const;
  inline void clear_replica_urls();
  static const int kReplicaUrlsFieldNumber = 8;
  inline const ::std::string& replica_urls(int index) const;
  inline ::std::string* mutable_replica_urls(int index);
  inline void set_replica_urls(int index, const ::std::string& value);
  inline void set_replica_urls(int index, const char* value);
  inline void set_replica_urls(int index, const char* value, size_t size);
  inline ::std::string* add_replica_urls();
  inline void add_replica_urls(const ::std::string& value);
  inline void add_replica_urls(const char* value);
  inline void add_replica_urls(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& replica_urls() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_replica_urls();
  
  // repeated .ms.ms_volume_gateway_cred user_gateway_creds = 9;
  inline int user_gateway_creds_size() const;
  inline void clear_user_gateway_creds();
  static const int kUserGatewayCredsFieldNumber = 9;
  inline const ::ms::ms_volume_gateway_cred& user_gateway_creds(int index) const;
  inline ::ms::ms_volume_gateway_cred* mutable_user_gateway_creds(int index);
  inline ::ms::ms_volume_gateway_cred* add_user_gateway_creds();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::ms_volume_gateway_cred >&
      user_gateway_creds() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::ms_volume_gateway_cred >*
      mutable_user_gateway_creds();
  
  // @@protoc_insertion_point(class_scope:ms.ms_volume_metadata)
 private:
  inline void set_has_blocksize();
  inline void clear_has_blocksize();
  inline void set_has_requester_id();
  inline void clear_has_requester_id();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_volume_id();
  inline void clear_has_volume_id();
  inline void set_has_volume_version();
  inline void clear_has_volume_version();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_description();
  inline void clear_has_description();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 blocksize_;
  ::google::protobuf::uint64 requester_id_;
  ::google::protobuf::uint64 owner_id_;
  ::google::protobuf::uint64 volume_id_;
  ::google::protobuf::uint64 volume_version_;
  ::std::string* name_;
  ::std::string* description_;
  ::google::protobuf::RepeatedPtrField< ::std::string> replica_urls_;
  ::google::protobuf::RepeatedPtrField< ::ms::ms_volume_gateway_cred > user_gateway_creds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_ms_2eproto();
  friend void protobuf_AssignDesc_ms_2eproto();
  friend void protobuf_ShutdownFile_ms_2eproto();
  
  void InitAsDefaultInstance();
  static ms_volume_metadata* default_instance_;
};
// ===================================================================


// ===================================================================

// ms_entry

// required int32 type = 1;
inline bool ms_entry::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ms_entry::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ms_entry::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ms_entry::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ms_entry::type() const {
  return type_;
}
inline void ms_entry::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int64 ctime_sec = 2;
inline bool ms_entry::has_ctime_sec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ms_entry::set_has_ctime_sec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ms_entry::clear_has_ctime_sec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ms_entry::clear_ctime_sec() {
  ctime_sec_ = GOOGLE_LONGLONG(0);
  clear_has_ctime_sec();
}
inline ::google::protobuf::int64 ms_entry::ctime_sec() const {
  return ctime_sec_;
}
inline void ms_entry::set_ctime_sec(::google::protobuf::int64 value) {
  set_has_ctime_sec();
  ctime_sec_ = value;
}

// required int64 ctime_nsec = 3;
inline bool ms_entry::has_ctime_nsec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ms_entry::set_has_ctime_nsec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ms_entry::clear_has_ctime_nsec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ms_entry::clear_ctime_nsec() {
  ctime_nsec_ = GOOGLE_LONGLONG(0);
  clear_has_ctime_nsec();
}
inline ::google::protobuf::int64 ms_entry::ctime_nsec() const {
  return ctime_nsec_;
}
inline void ms_entry::set_ctime_nsec(::google::protobuf::int64 value) {
  set_has_ctime_nsec();
  ctime_nsec_ = value;
}

// required int64 mtime_sec = 4;
inline bool ms_entry::has_mtime_sec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ms_entry::set_has_mtime_sec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ms_entry::clear_has_mtime_sec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ms_entry::clear_mtime_sec() {
  mtime_sec_ = GOOGLE_LONGLONG(0);
  clear_has_mtime_sec();
}
inline ::google::protobuf::int64 ms_entry::mtime_sec() const {
  return mtime_sec_;
}
inline void ms_entry::set_mtime_sec(::google::protobuf::int64 value) {
  set_has_mtime_sec();
  mtime_sec_ = value;
}

// required int32 mtime_nsec = 5;
inline bool ms_entry::has_mtime_nsec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ms_entry::set_has_mtime_nsec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ms_entry::clear_has_mtime_nsec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ms_entry::clear_mtime_nsec() {
  mtime_nsec_ = 0;
  clear_has_mtime_nsec();
}
inline ::google::protobuf::int32 ms_entry::mtime_nsec() const {
  return mtime_nsec_;
}
inline void ms_entry::set_mtime_nsec(::google::protobuf::int32 value) {
  set_has_mtime_nsec();
  mtime_nsec_ = value;
}

// required int32 owner = 6;
inline bool ms_entry::has_owner() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ms_entry::set_has_owner() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ms_entry::clear_has_owner() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ms_entry::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 ms_entry::owner() const {
  return owner_;
}
inline void ms_entry::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
}

// required int32 volume = 7;
inline bool ms_entry::has_volume() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ms_entry::set_has_volume() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ms_entry::clear_has_volume() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ms_entry::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 ms_entry::volume() const {
  return volume_;
}
inline void ms_entry::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
}

// required int32 mode = 8;
inline bool ms_entry::has_mode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ms_entry::set_has_mode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ms_entry::clear_has_mode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ms_entry::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 ms_entry::mode() const {
  return mode_;
}
inline void ms_entry::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
}

// required uint64 size = 9;
inline bool ms_entry::has_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ms_entry::set_has_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ms_entry::clear_has_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ms_entry::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 ms_entry::size() const {
  return size_;
}
inline void ms_entry::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// required int64 version = 10;
inline bool ms_entry::has_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ms_entry::set_has_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ms_entry::clear_has_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ms_entry::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::int64 ms_entry::version() const {
  return version_;
}
inline void ms_entry::set_version(::google::protobuf::int64 value) {
  set_has_version();
  version_ = value;
}

// required int32 max_read_freshness = 11;
inline bool ms_entry::has_max_read_freshness() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ms_entry::set_has_max_read_freshness() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ms_entry::clear_has_max_read_freshness() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ms_entry::clear_max_read_freshness() {
  max_read_freshness_ = 0;
  clear_has_max_read_freshness();
}
inline ::google::protobuf::int32 ms_entry::max_read_freshness() const {
  return max_read_freshness_;
}
inline void ms_entry::set_max_read_freshness(::google::protobuf::int32 value) {
  set_has_max_read_freshness();
  max_read_freshness_ = value;
}

// required int32 max_write_freshness = 12;
inline bool ms_entry::has_max_write_freshness() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ms_entry::set_has_max_write_freshness() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ms_entry::clear_has_max_write_freshness() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ms_entry::clear_max_write_freshness() {
  max_write_freshness_ = 0;
  clear_has_max_write_freshness();
}
inline ::google::protobuf::int32 ms_entry::max_write_freshness() const {
  return max_write_freshness_;
}
inline void ms_entry::set_max_write_freshness(::google::protobuf::int32 value) {
  set_has_max_write_freshness();
  max_write_freshness_ = value;
}

// required string path = 13;
inline bool ms_entry::has_path() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ms_entry::set_has_path() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ms_entry::clear_has_path() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ms_entry::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& ms_entry::path() const {
  return *path_;
}
inline void ms_entry::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void ms_entry::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void ms_entry::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ms_entry::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* ms_entry::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string url = 14;
inline bool ms_entry::has_url() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ms_entry::set_has_url() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ms_entry::clear_has_url() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ms_entry::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ms_entry::url() const {
  return *url_;
}
inline void ms_entry::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ms_entry::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ms_entry::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ms_entry::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ms_entry::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ms_update

// required int32 type = 1;
inline bool ms_update::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ms_update::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ms_update::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ms_update::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ms_update::type() const {
  return type_;
}
inline void ms_update::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required .ms.ms_entry entry = 2;
inline bool ms_update::has_entry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ms_update::set_has_entry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ms_update::clear_has_entry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ms_update::clear_entry() {
  if (entry_ != NULL) entry_->::ms::ms_entry::Clear();
  clear_has_entry();
}
inline const ::ms::ms_entry& ms_update::entry() const {
  return entry_ != NULL ? *entry_ : *default_instance_->entry_;
}
inline ::ms::ms_entry* ms_update::mutable_entry() {
  set_has_entry();
  if (entry_ == NULL) entry_ = new ::ms::ms_entry;
  return entry_;
}
inline ::ms::ms_entry* ms_update::release_entry() {
  clear_has_entry();
  ::ms::ms_entry* temp = entry_;
  entry_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ms_updates

// repeated .ms.ms_update updates = 1;
inline int ms_updates::updates_size() const {
  return updates_.size();
}
inline void ms_updates::clear_updates() {
  updates_.Clear();
}
inline const ::ms::ms_update& ms_updates::updates(int index) const {
  return updates_.Get(index);
}
inline ::ms::ms_update* ms_updates::mutable_updates(int index) {
  return updates_.Mutable(index);
}
inline ::ms::ms_update* ms_updates::add_updates() {
  return updates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::ms_update >&
ms_updates::updates() const {
  return updates_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::ms_update >*
ms_updates::mutable_updates() {
  return &updates_;
}

// -------------------------------------------------------------------

// ms_reply

// required int64 volume_version = 1;
inline bool ms_reply::has_volume_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ms_reply::set_has_volume_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ms_reply::clear_has_volume_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ms_reply::clear_volume_version() {
  volume_version_ = GOOGLE_LONGLONG(0);
  clear_has_volume_version();
}
inline ::google::protobuf::int64 ms_reply::volume_version() const {
  return volume_version_;
}
inline void ms_reply::set_volume_version(::google::protobuf::int64 value) {
  set_has_volume_version();
  volume_version_ = value;
}

// repeated .ms.ms_entry entries_dir = 2;
inline int ms_reply::entries_dir_size() const {
  return entries_dir_.size();
}
inline void ms_reply::clear_entries_dir() {
  entries_dir_.Clear();
}
inline const ::ms::ms_entry& ms_reply::entries_dir(int index) const {
  return entries_dir_.Get(index);
}
inline ::ms::ms_entry* ms_reply::mutable_entries_dir(int index) {
  return entries_dir_.Mutable(index);
}
inline ::ms::ms_entry* ms_reply::add_entries_dir() {
  return entries_dir_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::ms_entry >&
ms_reply::entries_dir() const {
  return entries_dir_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::ms_entry >*
ms_reply::mutable_entries_dir() {
  return &entries_dir_;
}

// repeated .ms.ms_entry entries_base = 3;
inline int ms_reply::entries_base_size() const {
  return entries_base_.size();
}
inline void ms_reply::clear_entries_base() {
  entries_base_.Clear();
}
inline const ::ms::ms_entry& ms_reply::entries_base(int index) const {
  return entries_base_.Get(index);
}
inline ::ms::ms_entry* ms_reply::mutable_entries_base(int index) {
  return entries_base_.Mutable(index);
}
inline ::ms::ms_entry* ms_reply::add_entries_base() {
  return entries_base_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::ms_entry >&
ms_reply::entries_base() const {
  return entries_base_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::ms_entry >*
ms_reply::mutable_entries_base() {
  return &entries_base_;
}

// required int32 error = 4;
inline bool ms_reply::has_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ms_reply::set_has_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ms_reply::clear_has_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ms_reply::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::google::protobuf::int32 ms_reply::error() const {
  return error_;
}
inline void ms_reply::set_error(::google::protobuf::int32 value) {
  set_has_error();
  error_ = value;
}

// optional string errormsg = 5;
inline bool ms_reply::has_errormsg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ms_reply::set_has_errormsg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ms_reply::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ms_reply::clear_errormsg() {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    errormsg_->clear();
  }
  clear_has_errormsg();
}
inline const ::std::string& ms_reply::errormsg() const {
  return *errormsg_;
}
inline void ms_reply::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void ms_reply::set_errormsg(const char* value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void ms_reply::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ms_reply::mutable_errormsg() {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  return errormsg_;
}
inline ::std::string* ms_reply::release_errormsg() {
  clear_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormsg_;
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ms_gateway_blockinfo

// required string fs_path = 10;
inline bool ms_gateway_blockinfo::has_fs_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ms_gateway_blockinfo::set_has_fs_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ms_gateway_blockinfo::clear_has_fs_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ms_gateway_blockinfo::clear_fs_path() {
  if (fs_path_ != &::google::protobuf::internal::kEmptyString) {
    fs_path_->clear();
  }
  clear_has_fs_path();
}
inline const ::std::string& ms_gateway_blockinfo::fs_path() const {
  return *fs_path_;
}
inline void ms_gateway_blockinfo::set_fs_path(const ::std::string& value) {
  set_has_fs_path();
  if (fs_path_ == &::google::protobuf::internal::kEmptyString) {
    fs_path_ = new ::std::string;
  }
  fs_path_->assign(value);
}
inline void ms_gateway_blockinfo::set_fs_path(const char* value) {
  set_has_fs_path();
  if (fs_path_ == &::google::protobuf::internal::kEmptyString) {
    fs_path_ = new ::std::string;
  }
  fs_path_->assign(value);
}
inline void ms_gateway_blockinfo::set_fs_path(const char* value, size_t size) {
  set_has_fs_path();
  if (fs_path_ == &::google::protobuf::internal::kEmptyString) {
    fs_path_ = new ::std::string;
  }
  fs_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ms_gateway_blockinfo::mutable_fs_path() {
  set_has_fs_path();
  if (fs_path_ == &::google::protobuf::internal::kEmptyString) {
    fs_path_ = new ::std::string;
  }
  return fs_path_;
}
inline ::std::string* ms_gateway_blockinfo::release_fs_path() {
  clear_has_fs_path();
  if (fs_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fs_path_;
    fs_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 file_version = 1;
inline bool ms_gateway_blockinfo::has_file_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ms_gateway_blockinfo::set_has_file_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ms_gateway_blockinfo::clear_has_file_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ms_gateway_blockinfo::clear_file_version() {
  file_version_ = GOOGLE_LONGLONG(0);
  clear_has_file_version();
}
inline ::google::protobuf::int64 ms_gateway_blockinfo::file_version() const {
  return file_version_;
}
inline void ms_gateway_blockinfo::set_file_version(::google::protobuf::int64 value) {
  set_has_file_version();
  file_version_ = value;
}

// required uint64 block_id = 2;
inline bool ms_gateway_blockinfo::has_block_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ms_gateway_blockinfo::set_has_block_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ms_gateway_blockinfo::clear_has_block_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ms_gateway_blockinfo::clear_block_id() {
  block_id_ = GOOGLE_ULONGLONG(0);
  clear_has_block_id();
}
inline ::google::protobuf::uint64 ms_gateway_blockinfo::block_id() const {
  return block_id_;
}
inline void ms_gateway_blockinfo::set_block_id(::google::protobuf::uint64 value) {
  set_has_block_id();
  block_id_ = value;
}

// required int64 block_version = 3;
inline bool ms_gateway_blockinfo::has_block_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ms_gateway_blockinfo::set_has_block_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ms_gateway_blockinfo::clear_has_block_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ms_gateway_blockinfo::clear_block_version() {
  block_version_ = GOOGLE_LONGLONG(0);
  clear_has_block_version();
}
inline ::google::protobuf::int64 ms_gateway_blockinfo::block_version() const {
  return block_version_;
}
inline void ms_gateway_blockinfo::set_block_version(::google::protobuf::int64 value) {
  set_has_block_version();
  block_version_ = value;
}

// required uint64 blocking_factor = 4;
inline bool ms_gateway_blockinfo::has_blocking_factor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ms_gateway_blockinfo::set_has_blocking_factor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ms_gateway_blockinfo::clear_has_blocking_factor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ms_gateway_blockinfo::clear_blocking_factor() {
  blocking_factor_ = GOOGLE_ULONGLONG(0);
  clear_has_blocking_factor();
}
inline ::google::protobuf::uint64 ms_gateway_blockinfo::blocking_factor() const {
  return blocking_factor_;
}
inline void ms_gateway_blockinfo::set_blocking_factor(::google::protobuf::uint64 value) {
  set_has_blocking_factor();
  blocking_factor_ = value;
}

// required int64 file_mtime_sec = 5;
inline bool ms_gateway_blockinfo::has_file_mtime_sec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ms_gateway_blockinfo::set_has_file_mtime_sec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ms_gateway_blockinfo::clear_has_file_mtime_sec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ms_gateway_blockinfo::clear_file_mtime_sec() {
  file_mtime_sec_ = GOOGLE_LONGLONG(0);
  clear_has_file_mtime_sec();
}
inline ::google::protobuf::int64 ms_gateway_blockinfo::file_mtime_sec() const {
  return file_mtime_sec_;
}
inline void ms_gateway_blockinfo::set_file_mtime_sec(::google::protobuf::int64 value) {
  set_has_file_mtime_sec();
  file_mtime_sec_ = value;
}

// required int32 file_mtime_nsec = 6;
inline bool ms_gateway_blockinfo::has_file_mtime_nsec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ms_gateway_blockinfo::set_has_file_mtime_nsec() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ms_gateway_blockinfo::clear_has_file_mtime_nsec() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ms_gateway_blockinfo::clear_file_mtime_nsec() {
  file_mtime_nsec_ = 0;
  clear_has_file_mtime_nsec();
}
inline ::google::protobuf::int32 ms_gateway_blockinfo::file_mtime_nsec() const {
  return file_mtime_nsec_;
}
inline void ms_gateway_blockinfo::set_file_mtime_nsec(::google::protobuf::int32 value) {
  set_has_file_mtime_nsec();
  file_mtime_nsec_ = value;
}

// optional int32 progress = 7;
inline bool ms_gateway_blockinfo::has_progress() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ms_gateway_blockinfo::set_has_progress() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ms_gateway_blockinfo::clear_has_progress() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ms_gateway_blockinfo::clear_progress() {
  progress_ = 0;
  clear_has_progress();
}
inline ::google::protobuf::int32 ms_gateway_blockinfo::progress() const {
  return progress_;
}
inline void ms_gateway_blockinfo::set_progress(::google::protobuf::int32 value) {
  set_has_progress();
  progress_ = value;
}

// optional int64 write_time = 8;
inline bool ms_gateway_blockinfo::has_write_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ms_gateway_blockinfo::set_has_write_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ms_gateway_blockinfo::clear_has_write_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ms_gateway_blockinfo::clear_write_time() {
  write_time_ = GOOGLE_LONGLONG(0);
  clear_has_write_time();
}
inline ::google::protobuf::int64 ms_gateway_blockinfo::write_time() const {
  return write_time_;
}
inline void ms_gateway_blockinfo::set_write_time(::google::protobuf::int64 value) {
  set_has_write_time();
  write_time_ = value;
}

// optional int64 session_id = 9;
inline bool ms_gateway_blockinfo::has_session_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ms_gateway_blockinfo::set_has_session_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ms_gateway_blockinfo::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ms_gateway_blockinfo::clear_session_id() {
  session_id_ = GOOGLE_LONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::int64 ms_gateway_blockinfo::session_id() const {
  return session_id_;
}
inline void ms_gateway_blockinfo::set_session_id(::google::protobuf::int64 value) {
  set_has_session_id();
  session_id_ = value;
}

// -------------------------------------------------------------------

// ms_volume_gateway_cred

// required int32 owner_id = 1;
inline bool ms_volume_gateway_cred::has_owner_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ms_volume_gateway_cred::set_has_owner_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ms_volume_gateway_cred::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ms_volume_gateway_cred::clear_owner_id() {
  owner_id_ = 0;
  clear_has_owner_id();
}
inline ::google::protobuf::int32 ms_volume_gateway_cred::owner_id() const {
  return owner_id_;
}
inline void ms_volume_gateway_cred::set_owner_id(::google::protobuf::int32 value) {
  set_has_owner_id();
  owner_id_ = value;
}

// required string username = 2;
inline bool ms_volume_gateway_cred::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ms_volume_gateway_cred::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ms_volume_gateway_cred::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ms_volume_gateway_cred::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ms_volume_gateway_cred::username() const {
  return *username_;
}
inline void ms_volume_gateway_cred::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ms_volume_gateway_cred::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ms_volume_gateway_cred::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ms_volume_gateway_cred::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ms_volume_gateway_cred::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string password_hash = 3;
inline bool ms_volume_gateway_cred::has_password_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ms_volume_gateway_cred::set_has_password_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ms_volume_gateway_cred::clear_has_password_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ms_volume_gateway_cred::clear_password_hash() {
  if (password_hash_ != &::google::protobuf::internal::kEmptyString) {
    password_hash_->clear();
  }
  clear_has_password_hash();
}
inline const ::std::string& ms_volume_gateway_cred::password_hash() const {
  return *password_hash_;
}
inline void ms_volume_gateway_cred::set_password_hash(const ::std::string& value) {
  set_has_password_hash();
  if (password_hash_ == &::google::protobuf::internal::kEmptyString) {
    password_hash_ = new ::std::string;
  }
  password_hash_->assign(value);
}
inline void ms_volume_gateway_cred::set_password_hash(const char* value) {
  set_has_password_hash();
  if (password_hash_ == &::google::protobuf::internal::kEmptyString) {
    password_hash_ = new ::std::string;
  }
  password_hash_->assign(value);
}
inline void ms_volume_gateway_cred::set_password_hash(const char* value, size_t size) {
  set_has_password_hash();
  if (password_hash_ == &::google::protobuf::internal::kEmptyString) {
    password_hash_ = new ::std::string;
  }
  password_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ms_volume_gateway_cred::mutable_password_hash() {
  set_has_password_hash();
  if (password_hash_ == &::google::protobuf::internal::kEmptyString) {
    password_hash_ = new ::std::string;
  }
  return password_hash_;
}
inline ::std::string* ms_volume_gateway_cred::release_password_hash() {
  clear_has_password_hash();
  if (password_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_hash_;
    password_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ms_volume_metadata

// required uint64 blocksize = 1;
inline bool ms_volume_metadata::has_blocksize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ms_volume_metadata::set_has_blocksize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ms_volume_metadata::clear_has_blocksize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ms_volume_metadata::clear_blocksize() {
  blocksize_ = GOOGLE_ULONGLONG(0);
  clear_has_blocksize();
}
inline ::google::protobuf::uint64 ms_volume_metadata::blocksize() const {
  return blocksize_;
}
inline void ms_volume_metadata::set_blocksize(::google::protobuf::uint64 value) {
  set_has_blocksize();
  blocksize_ = value;
}

// required uint64 requester_id = 2;
inline bool ms_volume_metadata::has_requester_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ms_volume_metadata::set_has_requester_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ms_volume_metadata::clear_has_requester_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ms_volume_metadata::clear_requester_id() {
  requester_id_ = GOOGLE_ULONGLONG(0);
  clear_has_requester_id();
}
inline ::google::protobuf::uint64 ms_volume_metadata::requester_id() const {
  return requester_id_;
}
inline void ms_volume_metadata::set_requester_id(::google::protobuf::uint64 value) {
  set_has_requester_id();
  requester_id_ = value;
}

// required uint64 owner_id = 3;
inline bool ms_volume_metadata::has_owner_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ms_volume_metadata::set_has_owner_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ms_volume_metadata::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ms_volume_metadata::clear_owner_id() {
  owner_id_ = GOOGLE_ULONGLONG(0);
  clear_has_owner_id();
}
inline ::google::protobuf::uint64 ms_volume_metadata::owner_id() const {
  return owner_id_;
}
inline void ms_volume_metadata::set_owner_id(::google::protobuf::uint64 value) {
  set_has_owner_id();
  owner_id_ = value;
}

// required uint64 volume_id = 4;
inline bool ms_volume_metadata::has_volume_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ms_volume_metadata::set_has_volume_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ms_volume_metadata::clear_has_volume_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ms_volume_metadata::clear_volume_id() {
  volume_id_ = GOOGLE_ULONGLONG(0);
  clear_has_volume_id();
}
inline ::google::protobuf::uint64 ms_volume_metadata::volume_id() const {
  return volume_id_;
}
inline void ms_volume_metadata::set_volume_id(::google::protobuf::uint64 value) {
  set_has_volume_id();
  volume_id_ = value;
}

// required uint64 volume_version = 5;
inline bool ms_volume_metadata::has_volume_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ms_volume_metadata::set_has_volume_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ms_volume_metadata::clear_has_volume_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ms_volume_metadata::clear_volume_version() {
  volume_version_ = GOOGLE_ULONGLONG(0);
  clear_has_volume_version();
}
inline ::google::protobuf::uint64 ms_volume_metadata::volume_version() const {
  return volume_version_;
}
inline void ms_volume_metadata::set_volume_version(::google::protobuf::uint64 value) {
  set_has_volume_version();
  volume_version_ = value;
}

// required string name = 6;
inline bool ms_volume_metadata::has_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ms_volume_metadata::set_has_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ms_volume_metadata::clear_has_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ms_volume_metadata::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ms_volume_metadata::name() const {
  return *name_;
}
inline void ms_volume_metadata::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ms_volume_metadata::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ms_volume_metadata::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ms_volume_metadata::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ms_volume_metadata::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string description = 7;
inline bool ms_volume_metadata::has_description() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ms_volume_metadata::set_has_description() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ms_volume_metadata::clear_has_description() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ms_volume_metadata::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ms_volume_metadata::description() const {
  return *description_;
}
inline void ms_volume_metadata::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ms_volume_metadata::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ms_volume_metadata::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ms_volume_metadata::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* ms_volume_metadata::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string replica_urls = 8;
inline int ms_volume_metadata::replica_urls_size() const {
  return replica_urls_.size();
}
inline void ms_volume_metadata::clear_replica_urls() {
  replica_urls_.Clear();
}
inline const ::std::string& ms_volume_metadata::replica_urls(int index) const {
  return replica_urls_.Get(index);
}
inline ::std::string* ms_volume_metadata::mutable_replica_urls(int index) {
  return replica_urls_.Mutable(index);
}
inline void ms_volume_metadata::set_replica_urls(int index, const ::std::string& value) {
  replica_urls_.Mutable(index)->assign(value);
}
inline void ms_volume_metadata::set_replica_urls(int index, const char* value) {
  replica_urls_.Mutable(index)->assign(value);
}
inline void ms_volume_metadata::set_replica_urls(int index, const char* value, size_t size) {
  replica_urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ms_volume_metadata::add_replica_urls() {
  return replica_urls_.Add();
}
inline void ms_volume_metadata::add_replica_urls(const ::std::string& value) {
  replica_urls_.Add()->assign(value);
}
inline void ms_volume_metadata::add_replica_urls(const char* value) {
  replica_urls_.Add()->assign(value);
}
inline void ms_volume_metadata::add_replica_urls(const char* value, size_t size) {
  replica_urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ms_volume_metadata::replica_urls() const {
  return replica_urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ms_volume_metadata::mutable_replica_urls() {
  return &replica_urls_;
}

// repeated .ms.ms_volume_gateway_cred user_gateway_creds = 9;
inline int ms_volume_metadata::user_gateway_creds_size() const {
  return user_gateway_creds_.size();
}
inline void ms_volume_metadata::clear_user_gateway_creds() {
  user_gateway_creds_.Clear();
}
inline const ::ms::ms_volume_gateway_cred& ms_volume_metadata::user_gateway_creds(int index) const {
  return user_gateway_creds_.Get(index);
}
inline ::ms::ms_volume_gateway_cred* ms_volume_metadata::mutable_user_gateway_creds(int index) {
  return user_gateway_creds_.Mutable(index);
}
inline ::ms::ms_volume_gateway_cred* ms_volume_metadata::add_user_gateway_creds() {
  return user_gateway_creds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::ms_volume_gateway_cred >&
ms_volume_metadata::user_gateway_creds() const {
  return user_gateway_creds_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::ms_volume_gateway_cred >*
ms_volume_metadata::mutable_user_gateway_creds() {
  return &user_gateway_creds_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ms

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ms::ms_entry_FileType>() {
  return ::ms::ms_entry_FileType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ms::ms_update_UpdateType>() {
  return ::ms::ms_update_UpdateType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ms::ms_gateway_blockinfo_ProgressType>() {
  return ::ms::ms_gateway_blockinfo_ProgressType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ms_2eproto__INCLUDED
